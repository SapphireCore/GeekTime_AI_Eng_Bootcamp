# 基于 LangChain + LangGraph 的狼人杀多智能体

## 1. 项目概览

本项目实现了一个**可运行的狼人杀多智能体样例系统**，具体实现方式如下：

- 使用 **LangChain + LangGraph** 框架；
- 包含 **5 名 AI 玩家**（2 狼人 + 3 村民）；
- 支持标准流程：
  - 夜晚行动 → 公布死亡 → 白天发言 → 投票处决 → 直至一方获胜；
- 每个 Agent 拥有：
  - 角色身份与长期记忆；
  - 基于局势和 RAG 的策略推理；
  - 狼人隐藏身份、村民推理身份的行为模式。

---

## 2. 技术栈与架构选择

### 2.1 技术栈

- **LangChain**
  - 对 LLM 封装 (`ChatOpenAI`)；
  - 构建简单的 RAG 检索器（FAISS 向量库）；
- **LangGraph**
  - 状态机风格的多 Agent 协作流程；
  - 使用 `StateGraph` + `conditional_edges` 实现阶段路由；
- 向量库：`FAISS`（内存版，便于 demo）；
- LLM：OpenAI GPT 系列（可替换为任意兼容接口）。

### 2.2 架构概览

- **Game Orchestrator (LangGraph)**
  - 管理整个游戏状态 `GameState`；
  - 分阶段调用不同节点：
    - `night` 夜晚阶段（狼人行动）  
    - `day_announce` 主持人公布昨晚结果  
    - `day_talk` 所有存活玩家发言  
    - `vote` 全员投票、执行、判定胜负  
- **Agents**
  - 玩家 Agent：P1~P5（均为 LLM，不同系统 Prompt + 长期记忆）；
  - 主持人 Agent：只负责叙述和控制流程，不参与阵营。
- **State 设计**
  - 玩家列表：`players: Dict[player_id, Player]`
    - `role`（wolf/villager）、`alive`、`memory`；
  - 全局历史：`history`（用于可视化、RAG 检索）；
  - 控制字段：`day`, `phase`, `last_night_kill`, `winner`。

### 2.3 关键权衡

1. **单一 LLM 实例 + 不同 Prompt vs 多实例**
   - 为了简化依赖和调用，代码中复用一个 `ChatOpenAI` 实例，
     通过系统 Prompt 区分「玩家身份」「主持人」。
   - 真正的工程项目中，可以按角色拆成不同 LLM 对象，便于限流和监控。

2. **LangGraph 粒度**
   - 当前 Demo 的节点粒度是「阶段级」：
     - 夜晚/白天/投票 为独立节点，
     - 每个节点内部再循环调用多个玩家。
   - 这种设计比「每个玩家一个节点」更简单易懂，
     但仍能体现 LangGraph 的状态机特征。
   - 如果需要更细粒度控制（如并行多玩家发言），可以将玩家行为拆成子图。

3. **RAG 简化实现**
   - 本项目只使用一个内存向量库 + 少量规则/策略文本，
     目的是展示「Agent 调用知识库」的模式，而非追求真实强度。
   - 真实项目中可以替换为：
     - 狼人杀规则文档 PDF；
     - 狼人杀实战对局记录；
     - 人类写的高质量策略文章等。

---

## 3. RAG 应用方式

### 3.1 知识库内容

本 Demo 中的 `RAG_DOCS` 包含三类知识：

1. **基础规则**：胜负条件、夜晚/白天流程；
2. **狼人策略**：如何隐藏身份、带节奏；
3. **村民策略**：如何从发言和投票中排查可疑目标；
4. **主持人职责**：只描述局面，不发表推理。

这些文本在启动时被切分并写入 FAISS，供所有 Agent 检索。

### 3.2 调用方式

在每次玩家决策前（夜晚行动 / 白天发言 / 投票），都会执行：

```python
rag_q = f"我在狼人杀中扮演{role}，当前阶段是{intent}，局面是：{public_view}。"
context = rag_context(rag_q)
···

然后在系统 Prompt 中注入来自策略资料库的参考信息：context. 这样可以保证同一套 LLM 在不同局面会关联不同的规则和策略片段；即使模型本身不熟悉狼人杀，也能通过 RAG 获得“游戏说明书”。

## 4. 关键模块说明
### 4.1 夜晚行动 (night)

- 找出所有存活的狼人；
- 逐个调用其 night_action 决策：
-- 通过自然语言输出“目标: Px 理由: ...”；

代码简单解析出目标 ID；

多个狼人提名的目标做“多数表决”（平票随机）；

更新 players[target].alive = False 和 last_night_kill。

### 4.2 白天公布 (day_announce)

交给主持人 Agent：

输入局面摘要（存活/死亡/昨晚死亡）；

输出一小段自然语言公告；

不进行任何推理，只作为「叙述型 Agent」。

### 4.3 白天发言 (day_talk)

按存活顺序，逐个玩家调用 day_speech：

使用局面信息 + 个人长期记忆 + RAG；

狼人倾向于“甩锅”，村民尝试理性分析；

所有发言都写入 history，便于 debug 和展示。

### 4.4 投票阶段 (vote)

存活玩家各自决定投票对象：

也是自然语言输出「投票: Px 理由: ...」；

解析出被投对象，统计票数；

票数最高者被处决（平票随机）；

然后根据存活狼/村民数量判断胜负条件。

## 5. 调试与扩展建议
### 5.1 调试方法

控制随机性

使用 init_game(seed=42) 固定身份与随机选择，方便复现实验；

如需更多随机性，可去掉或改变 seed。

观察日志

state["history"] 保存了完整的“对局日志”：

夜晚行为、白天发言、投票声明、主持人公告；

适合直接打印或写入文件，作为 Demo 的可视化输出。

Prompt 调整

如果发言太长或不听话，可以：

降低 temperature；

在系统 Prompt 中更强约束「不要暴露身份」「控制在 N 句以内」。

LangGraph 可视化

可选：使用 app.get_graph().draw_png("graph.png")
生成流程图（依 LangGraph 版本而定），在 PPT 中展示状态机结构。

5.2 扩展点（可写在总结或展望里）

增加角色：预言家、女巫、守卫等，在夜晚阶段增加更多节点；

把 history 存入外部数据库，做局后复盘和自动评估；

用前端（Streamlit / Gradio / FastAPI + HTML）做一个简单可视化界面；

增加人类玩家接口（由人类代替其中一个玩家 Agent）。
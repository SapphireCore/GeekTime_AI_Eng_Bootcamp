# 基于 LangChain + LangGraph 的狼人杀多智能体 Demo

## 1. 项目概览

本项目实现了一个**可运行的狼人杀多智能体样例系统**，满足题目对
「基于智能体协作的狼人杀游戏系统开发」的基础要求：

- 使用 **LangChain + LangGraph** 框架；
- 包含 **5 名 AI 玩家**（2 狼人 + 3 村民）；
- 支持标准流程：
  - 夜晚行动 → 公布死亡 → 白天发言 → 投票处决 → 直至一方获胜；
- 每个 Agent 拥有：
  - 角色身份与长期记忆；
  - 基于局势和 RAG 的策略推理；
  - 狼人隐藏身份、村民推理身份的行为模式。

本项目重点展示的是**多智能体协同 + RAG + 流程可视化**，方便课堂展示和代码讲解。

---

## 2. 技术栈与架构选择

### 2.1 技术栈

- **LangChain**
  - 对 LLM 封装 (`ChatOpenAI`)；
  - 构建简单的 RAG 检索器（FAISS 向量库）；
- **LangGraph**
  - 状态机风格的多 Agent 协作流程；
  - 使用 `StateGraph` + `conditional_edges` 实现阶段路由；
- 向量库：`FAISS`（内存版，便于 demo）；
- LLM：OpenAI GPT 系列（可替换为任意兼容接口）。

### 2.2 架构概览

![architecture](示意：可以在 PPT 里画成一页)

- **Game Orchestrator (LangGraph)**
  - 管理整个游戏状态 `GameState`；
  - 分阶段调用不同节点：
    - `night` 夜晚阶段（狼人行动）  
    - `day_announce` 主持人公布昨晚结果  
    - `day_talk` 所有存活玩家发言  
    - `vote` 全员投票、执行、判定胜负  
- **Agents**
  - 玩家 Agent：P1~P5（均为 LLM，不同系统 Prompt + 长期记忆）；
  - 主持人 Agent：只负责叙述和控制流程，不参与阵营。
- **State 设计**
  - 玩家列表：`players: Dict[player_id, Player]`
    - `role`（wolf/villager）、`alive`、`memory`；
  - 全局历史：`history`（用于可视化、RAG 检索）；
  - 控制字段：`day`, `phase`, `last_night_kill`, `winner`。

### 2.3 关键权衡

1. **单一 LLM 实例 + 不同 Prompt vs 多实例**
   - 为了简化依赖和调用，代码中复用一个 `ChatOpenAI` 实例，
     通过系统 Prompt 区分「玩家身份」「主持人」。
   - 真正的工程项目中，可以按角色拆成不同 LLM 对象，便于限流和监控。

2. **LangGraph 粒度**
   - 当前 Demo 的节点粒度是「阶段级」：
     - 夜晚/白天/投票 为独立节点，
     - 每个节点内部再循环调用多个玩家。
   - 这种设计比「每个玩家一个节点」更简单易懂，
     但仍能体现 LangGraph 的状态机特征。
   - 如果需要更细粒度控制（如并行多玩家发言），可以将玩家行为拆成子图。

3. **RAG 简化实现**
   - 本项目只使用一个内存向量库 + 少量规则/策略文本，
     目的是展示「Agent 调用知识库」的模式，而非追求真实强度。
   - 真实项目中可以替换为：
     - 狼人杀规则文档 PDF；
     - 狼人杀实战对局记录；
     - 人类写的高质量策略文章等。

---

## 3. RAG 应用方式

### 3.1 知识库内容

本 Demo 中的 `RAG_DOCS` 包含三类知识：

1. **基础规则**：胜负条件、夜晚/白天流程；
2. **狼人策略**：如何隐藏身份、带节奏；
3. **村民策略**：如何从发言和投票中排查可疑目标；
4. **主持人职责**：只描述局面，不发表推理。

这些文本在启动时被切分并写入 FAISS，供所有 Agent 检索。

### 3.2 调用方式

在每次玩家决策前（夜晚行动 / 白天发言 / 投票），都会执行：

```python
rag_q = f"我在狼人杀中扮演{role}，当前阶段是{intent}，局面是：{public_view}。"
context = rag_context(rag_q)
